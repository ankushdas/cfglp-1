
/*********************************************************************************************

                                cfglp : A CFG Language Processor
                                --------------------------------

               About:
               Implemented by Uday Khedker (http://www.cse.iitb.ac.in/~uday) for 
               the courses cs302+cs306: Language Processors (theory and lab) at
               IIT Bombay. Release date Jan 6, 2013. Copyrights reserved by Uday
               Khedker. This implemenation has been made available purely for
               academic purposes without any warranty of any kind.

               Please see the README file for some details. A doxygen generated
               documentation can be found at http://www.cse.iitb.ac.in/~uday/cfglp


***********************************************************************************************/

#include <iostream>
#include <cstdlib>
#include <string>
#include <vector>
#include <list>

using namespace std;


/*   
   Our AST consists of ast_Node objects. Each node has an operator with 
   a known arity. This is an abstract base class from which different
   kinds of AST nodes are derived. In this version we have four kinds
   of AST Nodes:

   - Assignment nodes (asgn_Ast) which are binary nodes.
   - Name nodes (name_Ast) which are leaf nodes and can appear in
     the RHS or LHS of assignment nodes.
   - Number nodes (num_Ast) which are leaf nodes and can appear only
     in the RHS of an assignment node.
   - Return node (ret_Ast) which is a leaf node corresponding to a special
     return statement generated by GCC in a cfg dump regardless of whether
     it is present in the input C program or not.

   These nodes have additional fields as appropriate.

   This file describes the interface. The implementation is contained in the
   file ast.cc.
*/

typedef enum {asgn, ret, name_Leaf, arti_var_Leaf, exp_var_Leaf, num_Leaf, plus_tree, mult_tree, minus_tree, divide_tree, uminus} ast_Op;
typedef enum {zero_Arity=0, unary=1, binary=2} ast_Arity;   

class ast_Node;
typedef ast_Node* ast_Ptr;
typedef list <ast_Ptr> * ast_List_Ptr;

class ast_Node
{   
  public:
    ast_Op t_op;          
    ast_Arity node_arity;

    ast_Node() {}
    virtual ~ast_Node() {}

    ast_Op get_Tree_Op() { return t_op; }
    
    ast_Arity get_Node_Arity() { return node_arity; }

    virtual void print_Node(ostream *p) = 0;
    
    /* Type checking functions */
    virtual void type_Check() ; 
    virtual value_Type get_Val_Type() ; 
    virtual entity_Type get_Entity_Type(); 
    virtual string get_Name() ; 
    
    /* Evaluation functions */
    virtual eval_Result evaluate() = 0;
    virtual eval_Result get_Value_of_Evaluation();
    virtual void set_Value_of_Evaluation(eval_Result res);
    virtual sym_Entry_Ptr get_Sym_Entry();

    /* Compilation functions */
    virtual ast_Code_Ptr compile();
};

class asgn_Ast: public ast_Node
{
    ast_Ptr left;
    ast_Ptr right;
    int lineno;

  public:
    asgn_Ast(ast_Ptr l, ast_Ptr  r, int line);
    ~asgn_Ast() {}
    asgn_Ast& operator=(const asgn_Ast& rhs);

    /* Type checking functions */
    void type_Check();
    entity_Type get_Entity_Type();
    int get_Line_Number();

    /* Evaluation functions */
    eval_Result evaluate();
    void print_Eval_Result(asgn_Ast * ast);

    /* Compilation functions */
    ast_Code_Ptr compile();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class name_Ast: public ast_Node
{
    string name;
    sym_Entry_Ptr sym_entry;

  public:
    name_Ast(string n);
    name_Ast(string n, sym_Entry_Ptr s);
    ~name_Ast() {}

    /* Common function required for many activities */
    sym_Entry_Ptr get_Sym_Entry();
    string get_Name();

    /* Type checking functions */
    value_Type get_Val_Type();
    entity_Type get_Entity_Type();

    /* Evaluation functions */
    eval_Result evaluate();
    eval_Result get_Value_of_Evaluation();
    void set_Value_of_Evaluation(eval_Result res);

    /* Other printing functions */
    void print_Node(ostream *p);
};

class num_Ast: public ast_Node
{
	public:
	num_Ast() {}
	~num_Ast() {}
	
	virtual value_Type get_Val_Type();
    virtual string get_Name();
    virtual eval_Result evaluate();
    virtual void print_Node(ostream* o);

};

class int_num_Ast: public num_Ast
{
    int num;
  public:
    int_num_Ast(int n);
    ~int_num_Ast() {}

    /* Common function required for many activities */
    int get_Num() { return num; }

    /* Evaluation functions */
    eval_Result evaluate();
    value_Type get_Val_Type();
    string get_Name();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class float_num_Ast: public num_Ast
{
    double num;
  public:
    float_num_Ast(double n);
    ~float_num_Ast() {}

    /* Common function required for many activities */
    double get_Num() { return num; }
    
    eval_Result evaluate();
    value_Type get_Val_Type();
    string get_Name();

    /* Evaluation functions */

    /* Other printing functions */
    void print_Node(ostream *p);
};


class ret_Ast: public ast_Node
{
  public:
    ret_Ast();
    ~ret_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Compilation functions */
    ast_Code_Ptr compile();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class exp_var_Ast: public ast_Node
{
    string name;
    sym_Entry_Ptr sym_entry;

  public:
    exp_var_Ast(string n);
    exp_var_Ast(string n, sym_Entry_Ptr s);
    ~exp_var_Ast() {}

    /* Common function required for many activities */
    sym_Entry_Ptr get_Sym_Entry();
    string get_Name();

    /* Type checking functions */
    value_Type get_Val_Type();
    entity_Type get_Entity_Type();

    /* Evaluation functions */
    eval_Result evaluate();
    //eval_Result get_Value_of_Evaluation();
    //void set_Value_of_Evaluation(eval_Result res);

    /* Other printing functions */
    void print_Node(ostream *p);
};


class arith_Ast: public ast_Node
{
	public:
	ast_Ptr left;
	ast_Ptr right;
	value_Type data_type;
	
	arith_Ast() {}
	~arith_Ast() {}
	
	value_Type get_Val_Type() { return data_type;}
    virtual void print_Node(ostream* fp);
    virtual eval_Result evaluate();
};

class mult_Ast: public arith_Ast
{
  public:
    mult_Ast(ast_Ptr l, ast_Ptr  r);
    ~mult_Ast() {}
    
    void print_Node(ostream *p);
    eval_Result evaluate();
};

class plus_Ast: public arith_Ast
{
  public:
    plus_Ast(ast_Ptr l, ast_Ptr  r);
    ~plus_Ast() {}
    
    void print_Node(ostream *p);
    eval_Result evaluate();
};

class minus_Ast: public arith_Ast
{
  public:
    minus_Ast(ast_Ptr l, ast_Ptr  r);
    ~minus_Ast() {}
    
    void print_Node(ostream *p);
    eval_Result evaluate();
};

class div_Ast: public arith_Ast
{
  public:
    div_Ast(ast_Ptr l, ast_Ptr  r);
    ~div_Ast() {}
    
    void print_Node(ostream *p);
    eval_Result evaluate();
};

class uminus_Ast: public arith_Ast
{
  public:
    uminus_Ast(ast_Ptr p);
    ~uminus_Ast() {}
	
	void print_Node(ostream *p);
	eval_Result evaluate();
};

